Object 클래스에서 toString(), equals(), hashcode() 를 오버라이딩 후 재정의 하여 사용

toString() 메소드의 기능과 선언부를 확인해보면
		 *  인스턴스가 생성될 때 사용한 full class name과 @ 그리고 16진수 해시코드가 문자열로 반환된다.

equals() 메소드는 매개변수로 전달받은 인스턴스와 == 연산하여 true or false를 반환한다.
		 *  즉 동일한 인스턴스인지를 비교하는 기능을 한다.
		 *
		 * 필기.
		 *  동일객체와 동등객체
		 *  동일객체 : 주소가 동일한 인스턴스를 동일객체라고 한다.
		 *  동등객체 : 주소는 다르더라도 필드값이 동일한 객체를 동등객체라고 한다.
		 * 
		 * 설명. equals() 메소드의 기본 기능은 동일객체 판단을 한다고 볼 수 있다. (동일성 확인)
		 * 
		 * 설명.
		 *  하지만 경우에 따라서는 동등객체를 동일 객체로 취급해서 비교하고 싶은 경우가 발생한다.
		 *  즉, 동일한 필드값을 가지는 객체를 같은 객체로 판단할 수 있도록 하는 경우를 말한다.
		 *  그러한 경우 equals() 메소드를 오버라이딩하여, 각각의 필드가 동일한 값을 가지는지를 확인하고
		 *  모든 필드값이 같은 값을 가지는 경우 true, 아닌 경우 false를 반환하도록 작성한다.

hashcode()
		 *  동일한 필드값을 가지는 동등객체를 인스턴스를 구분하는 hashCode가 같은 동일객체로 취급하기 위해서는
		 *  hashCode 메소드를 재정의하여 동일한 필드값을 가지는 경우 동일한 hashCode를 반환하여
		 *  동일객체로 취급해야 하는 경우가 종종 존재한다.

		/* ----------------------------------------------- */
		
		/* 설명. hashCode를 재정의 하지 않은 경우 문제점 */
		
		/* 설명.
		 *  key와 value를 쌍으로 저장하는 자료구조인 HashMap에
		 *  key로 홍길동전 정보를 가지는 Book 타입의 인스턴스를 사용했다.
		 *  HashMap에서 홍길동전 정보를 가지는 인스턴스로 값을 꺼내오려 할 때
		 *  hashCode가 재정의되어 동일한 필드인 경우 동일 hashCode가 반환되도록 작성되어 있지 않다면
		 *  예상한 결과값과 다르게 null값을 반환받는다.



charAt() : 해당 문자열의 특정 인덱스에 해당하는 문자를 반환한다.
		 *  인덱스는 0부터 시작하는 숫자 체계를 의미하며
		 *  인덱스를 벗어난 정수를 인자로 전달하는 경우에는 IndexOutOfBoundsException이 발생한다.

compareTo() : 인자로 전달된 문자열과 사전 순으로 비교를 하여
		 *  두 문자열이 같다면 0을 반환, 인자로 전달된 문자열보다 작으면 음수를,
		 *  크면 양수를 반환한다.
		 *  단, 이 메소드는 대소문자를 구분하여 비교한다.
compareToIgnoreCase() : 대소문자를 구분하지 않고 비교한다. */
concat() : 문자열에 인자로 전달된 문자열을 합치기해서 새로운 문자열을 반환한다.
		 *  원본 문자열에는 영향을 주지 않는다.
indexOf() : 문자열에서 특정 문자를 탐색하여 처음 일치하는 인덱스 위치를 정수형으로 반환한다.
		 *  단, 일치하는 문자가 없는 경우 -1을 반환한다.
lastIndexOf() : 문자열 탐색을 뒤에서부터 하고 처음 일치하는 위치의 인덱스를 반환한다.
		 *  단, 일치하는 문자가 없는 경우 -1을 반환한다.
trim() : 문자열의 앞 뒤에 공백을 제거한 문자열을 반환한다.
toLowerCase() : 모든 문자를 소문자로 변환시킨다.
		 *  toUpperCase() : 모든 문자를 대문자로 변환시킨다.
		 *  원본에는 영향을 주지 않는다.
substring() : 문자열의 일부분을 잘라내어 새로운 문자열을 반환한다.
		 *  원본에 영향을 주지 않는다.
replace() : 문자열에서 대체할 문자열로 기존 문자열을 변경해서 반환한다.
		 *  원본에 영향을 주지 않는다.
length() : 문자열의 길이를 정수형으로 반환한다.
isEmpty() : 문자열의 길이가 0이면 true를 반환, 아니면 false를 반환
		 *  길이가 0인 문자열은 null과는 다르다.


이스케이프(escape) 문자
		 *  문자열 내에서 사용하는 문자 중 특수문자를 표현하거나 특수기능을 사용할 때 사용하는 문자이다.
		 *  이스케이프문자        의미
		 *     \n         개행(줄바꿈)
		 *     \t         탭
		 *     \'         작은 따옴표
		 *     \"         큰따옴표
		 *     \\         역슬래쉬 표시
이스케이프 문자를 사용하는 특수문자(\\)
		 *  $ ^ * ( ) + | { } [ ] . ?



두 클래스는 스레드 동기화 기능 제공 여부에 따라 차이점이 있다.
		 *  StringBuilder : 스레드 동기화 기능 제공하지 않음
		 *                  스레드 동기화처리를 고려하지 않는 상황에서 StringBuffer보다 성능이 좋음
		 *  StringBuffer : 스레드 동기화 기능 제공 함
		 *                 성능면에서는 StringBuilder보다 느림
		 *  두 개의 차이는 스레드 동기화 유무이고, 현재 우리는 스레드를 고려하지 않기 때문에
		 *  StringBuilder를 이용할 것이다.


String과 StringBuilder
		 *  String : 불변이라는 특성을 가지고 있다.
		 *           문자열에 + 연산으로 합치기 하는 경우, 기존 인스턴스를 수정하는 것이 아닌,
		 *           새로운 인스턴스를 반환한다.
		 *           따라서 문자열 변경이 자주 일어나는 경우 성능 면에서 좋지 않다.
		 *           하지만 변하지 않는 문자열을 자주 읽어 들이는 경우에는 오히려 좋은 성능을 기대할 수 있다.
		 *  StringBuilder : 가변이라는 특성을 가지고 있다.
		 *                  문자열에 append() 메소드를 이용하여 합치기 하는 경우
		 *                  기존 인스턴스를 수정하기 때문에 새로운 인스턴스를 생성하지 않는다.
		 *                  따라서 잦은 문자열 변경이 일어나는 경우 String보다 성능이 좋다.
		 *
		 * 필기.
		 *  단, jdk 1.5 버전에서는 문자열의 + 연산이 StringBuilder의 append()로 컴파일이 된다.
		 *  따라서 성능에 큰 차이를 보이지는 않는다.
		 *  하지만 반복문에서 문자열의 + 연산을 수행하는 경우 StringBuilder 인스턴스를
		 *  반복 루프 시 마다 생성하기 때문에 성능에는 좋지 않은 영향을 준다.



capacity() : 용량(현재 버퍼의 크기)을 정수형으로 반환하는 메소드 (문자열 길이 + 16이 기본 용량) */
		System.out.println(sb1.capacity());
		
	 *  append() : 인자로 전달된 값을 문자열로 변환 후 기존 문자열의 마지막에 추가한다.
		 *  기본 용량을 초과하는 경우 (기존 문자열 + 1) * 2를 하여 용량을 확장시킨다.
		 *  https://stackoverflow.com/questions/3184244/stringbuilder-capacity
		
		 *  delete() : 시작 인덱스와 종료 인덱스를 이용해서 문자열에서 원하는 부문의 문자열을 제거한다.
		 *  deleteCharAt() : 문자열 인덱스를 이용해서 문자 하나를 제거한다.
		 *  둘 다 원본에 영향을 미친다.

		 *  insert() : 인자로 전달된 값을 문자열로 변환 후 지정한 인덱스 위치에 추가한다.
		 *  원본에 영향을 미친다.

		 *  reverse() :  문자열 인덱스 순번을 역순으로 재배열한다.
		 *  원본에 영향을 미친다.

		 *  String 클래스와 동일한 메소드도 있다.
		 *  charAt(), indexOf()/lastIndexOf(), length(), replace(), substring(), toString()

Calendar 클래스를 이용한 인스턴스 생성 방법에는 두 가지 방법이 있다.
		  *  1. getInstance() static 메소드를 이용해서 인스턴스를 반환받는 방법
		  *  2. 후손 클래스인 GregorianCalendar 클래스를 이용해서 인스턴스를 생성하는 방법

getInstance() static 메소드 이용 */
		 Calendar calendar = Calendar.getInstance();

Calendar birthDay = new GregorianCalendar(year, month, dayOfMonth, hour, min, second);
		
		 System.out.println(birthDay);
